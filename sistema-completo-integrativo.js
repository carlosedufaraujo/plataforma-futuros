#!/usr/bin/env node

/**
 * SISTEMA COMPLETO INTEGRATIVO - BOI GORDO INVESTIMENTOS
 * An√°lise, diagn√≥stico e corre√ß√£o autom√°tica usando conex√£o direta com Supabase
 */

const { createClient } = require('@supabase/supabase-js');

// Configura√ß√£o Supabase
const SUPABASE_URL = 'https://kdfevkbwohcajcwrqzor.supabase.co';
const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImtkZmV2a2J3b2hjYWpjd3Jxem9yIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTMzMTUzODcsImV4cCI6MjA2ODg5MTM4N30.4nBjKi3rdpfbYmxeoa8GELdBLq8JY6ym68cJX7jpaus';

// Criar cliente Supabase
const supabase = createClient(SUPABASE_URL, SUPABASE_ANON_KEY);

// IDs dos usu√°rios principais
const CARLOS_ID = '59ecd002-468c-41a9-b32f-23555303e5a4';
const ANGELO_ID = '7f2dab2b-6772-46a7-9913-28247d0e6485';

class SistemaCompleto {
  constructor() {
    this.resultados = {
      analise: {},
      problemas: [],
      correcoes: [],
      testes: {}
    };
  }

  log(emoji, mensagem) {
    console.log(`${emoji} ${mensagem}`);
  }

  async executar() {
    this.log('üöÄ', 'INICIANDO AN√ÅLISE COMPLETA DO SISTEMA...');
    console.log('='.repeat(60));

    try {
      // 1. An√°lise da estrutura
      await this.analisarEstrutura();
      
      // 2. Verificar usu√°rios
      await this.verificarUsuarios();
      
      // 3. Analisar dados
      await this.analisarDados();
      
      // 4. Testar queries problem√°ticas
      await this.testarQueriesProblematicas();
      
      // 5. Executar corre√ß√µes se necess√°rio
      await this.executarCorrecoes();
      
      // 6. Testes finais
      await this.testesFinais();
      
      // 7. Relat√≥rio final
      this.relatorioFinal();

    } catch (error) {
      this.log('‚ùå', `ERRO CR√çTICO: ${error.message}`);
      console.error('Stack:', error.stack);
    }
  }

  async analisarEstrutura() {
    this.log('üìä', 'PASSO 1: ANALISANDO ESTRUTURA DO BANCO...');
    
    // Verificar tabelas existentes
    const tabelasEssenciais = ['users', 'brokerages', 'user_brokerages', 'contracts', 'positions', 'transactions', 'options'];
    
    for (const tabela of tabelasEssenciais) {
      try {
        const { count, error } = await supabase
          .from(tabela)
          .select('*', { count: 'exact', head: true });
        
        if (error) {
          this.log('‚ùå', `Tabela ${tabela}: ERRO - ${error.message}`);
          this.resultados.problemas.push(`Tabela ${tabela} inacess√≠vel: ${error.message}`);
        } else {
          this.log('‚úÖ', `Tabela ${tabela}: ${count} registros`);
          this.resultados.analise[tabela] = count;
        }
      } catch (err) {
        this.log('‚ùå', `Tabela ${tabela}: EXCE√á√ÉO - ${err.message}`);
        this.resultados.problemas.push(`Tabela ${tabela} erro cr√≠tico: ${err.message}`);
      }
    }
  }

  async verificarUsuarios() {
    this.log('üë•', 'PASSO 2: VERIFICANDO USU√ÅRIOS...');
    
    try {
      // Verificar se Carlos e √Çngelo existem
      const { data: usuarios, error } = await supabase
        .from('users')
        .select('*')
        .in('id', [CARLOS_ID, ANGELO_ID]);
      
      if (error) {
        this.log('‚ùå', `Erro ao buscar usu√°rios: ${error.message}`);
        this.resultados.problemas.push(`Usu√°rios inacess√≠veis: ${error.message}`);
        return;
      }

      const carlos = usuarios.find(u => u.id === CARLOS_ID);
      const angelo = usuarios.find(u => u.id === ANGELO_ID);

      if (carlos) {
        this.log('‚úÖ', `Carlos Eduardo encontrado - Role: ${carlos.role}`);
        if (carlos.role !== 'admin') {
          this.resultados.problemas.push('Carlos n√£o √© admin');
        }
      } else {
        this.log('‚ùå', 'Carlos Eduardo N√ÉO encontrado');
        this.resultados.problemas.push('Carlos Eduardo ausente');
      }

      if (angelo) {
        this.log('‚úÖ', `√Çngelo Caiado encontrado - Role: ${angelo.role}`);
      } else {
        this.log('‚ùå', '√Çngelo Caiado N√ÉO encontrado');
        this.resultados.problemas.push('√Çngelo Caiado ausente');
      }

      this.resultados.analise.usuarios = { carlos, angelo };

    } catch (err) {
      this.log('‚ùå', `Erro cr√≠tico na verifica√ß√£o de usu√°rios: ${err.message}`);
      this.resultados.problemas.push(`Verifica√ß√£o usu√°rios falhou: ${err.message}`);
    }
  }

  async analisarDados() {
    this.log('üíæ', 'PASSO 3: ANALISANDO DADOS POR USU√ÅRIO...');
    
    const tabelas = ['positions', 'transactions', 'options'];
    
    for (const tabela of tabelas) {
      try {
        // Dados do Carlos
        const { count: carlosCount } = await supabase
          .from(tabela)
          .select('*', { count: 'exact', head: true })
          .eq('user_id', CARLOS_ID);

        // Dados do √Çngelo
        const { count: angeloCount } = await supabase
          .from(tabela)
          .select('*', { count: 'exact', head: true })
          .eq('user_id', ANGELO_ID);

        this.log('üìä', `${tabela}: Carlos=${carlosCount || 0}, √Çngelo=${angeloCount || 0}`);
        
        // Problema espec√≠fico: √Çngelo sem transactions (causa erro 406)
        if (tabela === 'transactions' && (angeloCount === 0 || angeloCount === null)) {
          this.log('‚ö†Ô∏è', 'PROBLEMA CR√çTICO: √Çngelo sem transactions (causa erro 406)');
          this.resultados.problemas.push('√Çngelo sem transactions - erro 406');
        }

        this.resultados.analise[`${tabela}_por_usuario`] = {
          carlos: carlosCount || 0,
          angelo: angeloCount || 0
        };

      } catch (err) {
        this.log('‚ùå', `Erro ao analisar ${tabela}: ${err.message}`);
        this.resultados.problemas.push(`An√°lise ${tabela} falhou: ${err.message}`);
      }
    }
  }

  async testarQueriesProblematicas() {
    this.log('üß™', 'PASSO 4: TESTANDO QUERIES PROBLEM√ÅTICAS...');
    
    // Testar query que causava erro 406
    try {
      this.log('üîç', 'Testando query transactions do √Çngelo (ORDER BY date DESC LIMIT 1)...');
      
      const { data, error } = await supabase
        .from('transactions')
        .select('*')
        .eq('user_id', ANGELO_ID)
        .order('date', { ascending: false })
        .limit(1);

      if (error) {
        this.log('‚ùå', `Query transactions falhou: ${error.message}`);
        this.resultados.problemas.push(`Query transactions erro: ${error.message}`);
      } else if (!data || data.length === 0) {
        this.log('‚ö†Ô∏è', 'Query transactions retornou vazio (causa erro 406)');
        this.resultados.problemas.push('Query transactions vazia - erro 406');
      } else {
        this.log('‚úÖ', `Query transactions OK: ${data.length} resultado(s)`);
        this.resultados.testes.query_transactions = 'OK';
      }

    } catch (err) {
      this.log('‚ùå', `Erro cr√≠tico na query transactions: ${err.message}`);
      this.resultados.problemas.push(`Query transactions exce√ß√£o: ${err.message}`);
    }

    // Testar outras queries cr√≠ticas
    try {
      // Testar acesso a brokerages
      const { data: brokerages, error: brokError } = await supabase
        .from('brokerages')
        .select('*')
        .limit(1);

      if (brokError) {
        this.log('‚ùå', `Query brokerages falhou: ${brokError.message}`);
        this.resultados.problemas.push(`Query brokerages erro: ${brokError.message}`);
      } else {
        this.log('‚úÖ', `Query brokerages OK: ${brokerages?.length || 0} resultado(s)`);
        this.resultados.testes.query_brokerages = 'OK';
      }

    } catch (err) {
      this.log('‚ùå', `Erro cr√≠tico nas queries de teste: ${err.message}`);
      this.resultados.problemas.push(`Queries teste exce√ß√£o: ${err.message}`);
    }
  }

  async executarCorrecoes() {
    this.log('üîß', 'PASSO 5: EXECUTANDO CORRE√á√ïES AUTOM√ÅTICAS...');
    
    if (this.resultados.problemas.length === 0) {
      this.log('‚úÖ', 'Nenhuma corre√ß√£o necess√°ria!');
      return;
    }

    this.log('‚ö†Ô∏è', `${this.resultados.problemas.length} problema(s) identificado(s)`);
    
    // Corre√ß√£o 1: Inserir transactions para √Çngelo se necess√°rio
    if (this.resultados.problemas.some(p => p.includes('transactions'))) {
      await this.corrigirTransactionsAngelo();
    }

    // Corre√ß√£o 2: Garantir role admin para Carlos se necess√°rio
    if (this.resultados.problemas.some(p => p.includes('admin'))) {
      await this.corrigirRoleCarlos();
    }

    // Corre√ß√£o 3: Inserir dados b√°sicos se necess√°rio
    if (this.resultados.problemas.some(p => p.includes('ausente'))) {
      await this.inserirDadosBasicos();
    }
  }

  async corrigirTransactionsAngelo() {
    this.log('üîß', 'Corrigindo transactions do √Çngelo...');
    
    try {
      // Inserir algumas transactions b√°sicas
      const transactionsExemplo = [
        {
          user_id: ANGELO_ID,
          date: new Date(Date.now() - 2 * 24 * 60 * 60 * 1000).toISOString(), // 2 dias atr√°s
          type: 'COMPRA',
          contract: 'CCMK25',
          quantity: 75,
          price: 46.80,
          total: 3510.00,
          fees: 20.00,
          status: 'EXECUTADA'
        },
        {
          user_id: ANGELO_ID,
          date: new Date(Date.now() - 1 * 24 * 60 * 60 * 1000).toISOString(), // 1 dia atr√°s
          type: 'VENDA',
          contract: 'SOJK25',
          quantity: 25,
          price: 65.00,
          total: 1625.00,
          fees: 12.50,
          status: 'EXECUTADA'
        },
        {
          user_id: ANGELO_ID,
          date: new Date(Date.now() - 1 * 60 * 60 * 1000).toISOString(), // 1 hora atr√°s
          type: 'COMPRA',
          contract: 'CCMK25',
          quantity: 25,
          price: 47.20,
          total: 1180.00,
          fees: 8.00,
          status: 'EXECUTADA'
        }
      ];

      const { data, error } = await supabase
        .from('transactions')
        .insert(transactionsExemplo)
        .select();

      if (error) {
        this.log('‚ùå', `Erro ao inserir transactions: ${error.message}`);
        this.resultados.problemas.push(`Corre√ß√£o transactions falhou: ${error.message}`);
      } else {
        this.log('‚úÖ', `${data.length} transactions inseridas para √Çngelo`);
        this.resultados.correcoes.push(`${data.length} transactions inseridas para √Çngelo`);
      }

    } catch (err) {
      this.log('‚ùå', `Erro cr√≠tico na corre√ß√£o transactions: ${err.message}`);
      this.resultados.problemas.push(`Corre√ß√£o transactions exce√ß√£o: ${err.message}`);
    }
  }

  async corrigirRoleCarlos() {
    this.log('üîß', 'Corrigindo role admin do Carlos...');
    
    try {
      const { data, error } = await supabase
        .from('users')
        .update({ role: 'admin' })
        .eq('id', CARLOS_ID)
        .select();

      if (error) {
        this.log('‚ùå', `Erro ao atualizar role Carlos: ${error.message}`);
        this.resultados.problemas.push(`Corre√ß√£o role Carlos falhou: ${error.message}`);
      } else {
        this.log('‚úÖ', 'Role admin definida para Carlos');
        this.resultados.correcoes.push('Role admin definida para Carlos');
      }

    } catch (err) {
      this.log('‚ùå', `Erro cr√≠tico na corre√ß√£o role Carlos: ${err.message}`);
      this.resultados.problemas.push(`Corre√ß√£o role Carlos exce√ß√£o: ${err.message}`);
    }
  }

  async inserirDadosBasicos() {
    this.log('üîß', 'Inserindo dados b√°sicos se necess√°rio...');
    
    // Se n√£o existir brokerages, inserir algumas b√°sicas
    try {
      const { count: brokerageCount } = await supabase
        .from('brokerages')
        .select('*', { count: 'exact', head: true });

      if (!brokerageCount || brokerageCount === 0) {
        const brokeragesBasicas = [
          { name: 'Clear Corretora', code: 'CLEAR', is_active: true },
          { name: 'XP Investimentos', code: 'XP', is_active: true }
        ];

        const { data, error } = await supabase
          .from('brokerages')
          .insert(brokeragesBasicas)
          .select();

        if (error) {
          this.log('‚ùå', `Erro ao inserir brokerages: ${error.message}`);
        } else {
          this.log('‚úÖ', `${data.length} brokerages b√°sicas inseridas`);
          this.resultados.correcoes.push(`${data.length} brokerages inseridas`);
        }
      }

    } catch (err) {
      this.log('‚ùå', `Erro na inser√ß√£o de dados b√°sicos: ${err.message}`);
    }
  }

  async testesFinais() {
    this.log('üß™', 'PASSO 6: TESTES FINAIS DO SISTEMA...');
    
    // Re-testar query que causava erro 406
    try {
      const { data, error } = await supabase
        .from('transactions')
        .select('*')
        .eq('user_id', ANGELO_ID)
        .order('date', { ascending: false })
        .limit(1);

      if (error) {
        this.log('‚ùå', `TESTE FINAL FALHOU: ${error.message}`);
        this.resultados.testes.final_transactions = 'FALHOU';
      } else if (!data || data.length === 0) {
        this.log('‚ùå', 'TESTE FINAL: Ainda sem transactions para √Çngelo');
        this.resultados.testes.final_transactions = 'VAZIO';
      } else {
        this.log('‚úÖ', 'TESTE FINAL: Query transactions funcionando!');
        this.resultados.testes.final_transactions = 'OK';
      }

    } catch (err) {
      this.log('‚ùå', `TESTE FINAL EXCE√á√ÉO: ${err.message}`);
      this.resultados.testes.final_transactions = 'EXCE√á√ÉO';
    }

    // Teste de contagem final
    try {
      const { count: positionsCount } = await supabase
        .from('positions')
        .select('*', { count: 'exact', head: true });

      const { count: transactionsCount } = await supabase
        .from('transactions')
        .select('*', { count: 'exact', head: true });

      const { count: usersCount } = await supabase
        .from('users')
        .select('*', { count: 'exact', head: true });

      this.log('üìä', `CONTAGEM FINAL: ${usersCount} usu√°rios, ${positionsCount} positions, ${transactionsCount} transactions`);
      
      this.resultados.testes.contagem_final = {
        users: usersCount,
        positions: positionsCount,
        transactions: transactionsCount
      };

    } catch (err) {
      this.log('‚ùå', `Erro na contagem final: ${err.message}`);
    }
  }

  relatorioFinal() {
    console.log('\n' + '='.repeat(60));
    this.log('üéâ', 'RELAT√ìRIO FINAL DO SISTEMA');
    console.log('='.repeat(60));

    // Status geral
    const problemas = this.resultados.problemas.length;
    const correcoes = this.resultados.correcoes.length;
    
    if (problemas === 0) {
      this.log('‚úÖ', 'SISTEMA TOTALMENTE FUNCIONAL!');
    } else if (correcoes > 0) {
      this.log('üîß', `${correcoes} CORRE√á√ïES APLICADAS, ${problemas} problemas identificados`);
    } else {
      this.log('‚ùå', `${problemas} PROBLEMAS PENDENTES`);
    }

    // Detalhes da an√°lise
    console.log('\nüìä AN√ÅLISE DAS TABELAS:');
    Object.entries(this.resultados.analise).forEach(([key, value]) => {
      if (typeof value === 'number') {
        console.log(`   ${key}: ${value} registros`);
      }
    });

    // Problemas encontrados
    if (this.resultados.problemas.length > 0) {
      console.log('\n‚ö†Ô∏è  PROBLEMAS IDENTIFICADOS:');
      this.resultados.problemas.forEach((problema, i) => {
        console.log(`   ${i + 1}. ${problema}`);
      });
    }

    // Corre√ß√µes aplicadas
    if (this.resultados.correcoes.length > 0) {
      console.log('\nüîß CORRE√á√ïES APLICADAS:');
      this.resultados.correcoes.forEach((correcao, i) => {
        console.log(`   ${i + 1}. ${correcao}`);
      });
    }

    // Testes finais
    console.log('\nüß™ RESULTADOS DOS TESTES:');
    Object.entries(this.resultados.testes).forEach(([teste, resultado]) => {
      const emoji = resultado === 'OK' ? '‚úÖ' : '‚ùå';
      console.log(`   ${emoji} ${teste}: ${resultado}`);
    });

    // Recomenda√ß√µes finais
    console.log('\nüöÄ PR√ìXIMOS PASSOS:');
    if (this.resultados.testes.final_transactions === 'OK') {
      console.log('   ‚úÖ Erro 406 deve estar resolvido');
      console.log('   ‚úÖ Sistema pronto para uso');
      console.log('   üåê Teste em: http://localhost:3000');
    } else {
      console.log('   ‚ö†Ô∏è  Ainda h√° problemas na query transactions');
      console.log('   üîß Execute corre√ß√µes manuais se necess√°rio');
    }

    console.log('\n' + '='.repeat(60));
  }
}

// Executar o sistema
async function main() {
  const sistema = new SistemaCompleto();
  await sistema.executar();
}

// Executar se for chamado diretamente
if (require.main === module) {
  main().catch(console.error);
}

module.exports = SistemaCompleto; 